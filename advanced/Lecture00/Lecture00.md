## Linux 平台 C/C++ 内存调试指南

因为 C/C++ 没有 Garbage Collection 机制，这使得它们可以做到很高效，但因此也容易产生内存方面的 bug 。
主要分为内存非法访问和内存泄漏两方面。
C/C++ 语法上对存在内存泄漏的程序(即申请了动态内存但没释放就退出了)不提供任何保证，即不保证操作系统会回收泄漏的内存。
现代操作系统基本会在程序结束后立刻回收程序使用的所有内存，否则一旦发生内存泄漏的程序很多，系统很容易崩溃。
比如Linux，会为每个程序建立一个虚拟内存空间(程序只知道虚拟内存地址，操作系统完全知道虚拟内存地址到物理内存地址的转换，也即操作系统能够监控到程序使用的所有内存)，程序结束后即会销毁这个空间，也即回收了内存。
但是注意，并非所有系统都会做这一步，在一些实时的操作系统中，为了效率考虑(内存回收需要不少的代价)则不会做类似的处理，依赖程序员自身来保证程序正确性。

虽然内存调试会很麻烦，但是为了性能考虑，几乎所有的操作系统和系统软件都会采用C/C++来实现。
数据库系统也是如此，但凡强调性能的数据库系统，都要在底层使用 C/C++ 。

Valgrind

输出日志  log4cplus

---

#### stack

数组太大

递归调用太深，爆栈

类型溢出导致的各种问题，如非法读写

---

#### heap memory

delete/free/delete[]/new/new[]/malloc 不匹配

尝试释放p+10，但p才是分配的内容起始地址

释放之后再去读

double free

free an invalid address

read/write an invalid address


C++中检查new的返回值与C语言中对malloc的检查不同，必须处理异常而不是判断指针是否非空：

https://blog.csdn.net/hbyzl/article/details/8096007

---

