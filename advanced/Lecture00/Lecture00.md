## Linux 平台 C/C++ 内存调试指南

因为 C/C++ 没有 Garbage Collection 机制，这使得它们可以做到很高效，但因此也容易产生内存方面的 bug 。
主要分为内存非法访问和内存泄漏两方面。
C/C++ 语法上对存在内存泄漏的程序(即申请了动态内存但没释放就退出了)不提供任何保证，即不保证操作系统会回收泄漏的内存。
现代操作系统基本会在程序结束后立刻回收程序使用的所有内存，否则一旦发生内存泄漏的程序很多，系统很容易崩溃。
比如Linux，会为每个程序建立一个虚拟内存空间(程序只知道虚拟内存地址，操作系统完全知道虚拟内存地址到物理内存地址的转换，也即操作系统能够监控到程序使用的所有内存)，程序结束后即会销毁这个空间，也即回收了内存。
但是注意，并非所有系统都会做这一步，在一些实时的操作系统中，为了效率考虑(内存回收需要不少的代价)则不会做类似的处理，依赖程序员自身来保证程序正确性。

最麻烦的地方在于，内存错误不一定会立刻报错，而是可能积累到一定程度才报错，而报错的地方不一定是真正出错的地方。
有时候不同机器上表现也不同，小机器(如笔记本)上报错，但大的服务器上可能就不会报错。

虽然内存调试会很麻烦，但是为了性能考虑，几乎所有的操作系统和系统软件都会采用C/C++来实现。
数据库系统也是如此，但凡强调性能的数据库系统，都要在底层使用 C/C++ 。

Valgrind

输出日志  log4cplus

---

#### stack

数组太大

递归调用太深，爆栈

类型溢出导致的各种问题，如非法读写

---

#### heap memory

delete/free/delete[]/new/new[]/malloc 不匹配

尝试释放p+10，但p才是分配的内容起始地址

释放之后再去读

double free

free an invalid address

read/write an invalid address


C++中检查new的返回值与C语言中对malloc的检查不同，必须处理异常而不是判断指针是否非空：

https://blog.csdn.net/hbyzl/article/details/8096007

---

#### Core Dump

gdb -c core.*

kill -s SIGSEGV PID

http://blog.sina.com.cn/s/blog_81fcea16010130w9.html

默认情况下，core dump生成的文件名为core，而且就在程序当前目录下。新的core会覆盖已存在的core。通过修改/proc/sys/kernel/core_uses_pid文件，可以将进程的pid作为作为扩展名，生成的core文件格式为core.xxx，其中xxx即为pid

https://blog.csdn.net/zzhongcy/article/details/42873015

http://blog.chinaunix.net/uid-20279362-id-4962658.html

---

#### 心得体会

就我的个人看法，做研究的人，从问题中升华得到经验和教训，远比解决一个具体的问题要重要。如果是一个比较有代码经验的人来做这个事情，当常规调试策略全部失败的时候，可以考虑以下几种做法：

1. 请一个在这方面非常专业的人来帮忙寻找问题，这种是最快的，但也更可能找不到。也可以请一个这方面不太了解的人来帮忙调试，毕竟不了解就更可能提出问题。（但这2种让别人帮忙调试的做法，是最不可取的）

2. 用gdb或cuda-gdb强行单步调试，这需要你去学这个工具，但一旦学会，受益终生

3. 通读文档。就像之前我遇到的那个动态申请堆内存的bug，以及你这个，其实都是可以通过先读一遍cuda文档解决的。上面说的很精要很明白，只是我们很多时候不愿花时间，总想取巧罢了

4. 强行倒推。我们可以先精简代码，比如一千行的代码跑不起来，我们可以先尝试注释掉某个功能模块，把它变为五百行。不行的话就再精简，去除一些功能，变成一个简单的代码框架，直到不报bug为止。然后，从这个运行正确的代码开始，我们可以不断地把已有的功能加进去，一直加到出问题为止。这样，我们就找到了出问题的功能模块，接下来只要对这个功能模块展开分析就行

以上这些就是调试时一些非常规的方法，都是我在做gstore系统的时候总结出来的，毕竟我接手这个系统的时候，并没有人指导。
但是所有的问题，总是能找到解决方法的。
对于一些不是很关键的问题，大可以用一些简单粗暴的方法，比如：
不行就分，喜欢就买，重启试试。

---

